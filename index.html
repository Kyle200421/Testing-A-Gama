<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Treasure Hunter Game</title>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(45deg, #1a1a2e, #16213e);
            font-family: Arial, sans-serif;
        }
        #gameContainer {
            position: relative;
            width: 800px;
            text-align: center;
        }
        #gameCanvas {
            border: 3px solid #e94560;
            border-radius: 10px;
            background: linear-gradient(180deg, #87CEEB 0%, #4A90E2 100%);
            display: none;
        }
        #score, #highScore {
            color: #fff;
            font-size: 24px;
            margin: 10px 0;
            display: none;
        }
        #highScore {
            color: #ffd700;
            font-size: 20px;
        }
        .menu {
            background: rgba(0, 0, 0, 0.85);
            padding: 40px;
            border-radius: 15px;
            border: 3px solid #e94560;
            text-align: center;
            animation: fadeIn 0.5s ease-in;
        }
        .menu h1 {
            color: #e94560;
            font-size: 48px;
            margin: 0 0 30px 0;
            text-shadow: 0 0 10px rgba(233, 69, 96, 0.5);
        }
        .menu-btn {
            display: block;
            width: 200px;
            padding: 15px 20px;
            font-size: 20px;
            background-color: #e94560;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 15px auto;
            transition: all 0.3s ease;
        }
        .menu-btn:hover {
            transform: scale(1.1);
            background-color: #ff5472;
        }
        #restartBtn {
            background-color: #4CAF50;  /* Green color for restart */
        }
        #restartBtn:hover {
            background-color: #45a049;
        }
        .game-over-overlay {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.85);
            padding: 30px;
            border-radius: 15px;
            border: 3px solid #e94560;
            text-align: center;
            animation: fadeIn 0.5s ease-in;
        }
        .game-over-overlay h1 {
            color: #e94560;
            font-size: 48px;
            margin: 0 0 20px 0;
            text-shadow: 0 0 10px rgba(233, 69, 96, 0.5);
        }
        .game-over-overlay p {
            color: #fff;
            font-size: 24px;
            margin: 10px 0;
        }
        .final-score {
            color: #ffd700;
            font-size: 36px;
            margin: 20px 0;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        .controls-info {
            color: #fff;
            font-size: 18px;
            margin: 20px 0;
            text-align: left;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }
        #controlsButton {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(233, 69, 96, 0.8);
            color: white;
            border: none;
            border-radius: 5px;
            padding: 8px 15px;
            cursor: pointer;
            font-size: 14px;
            z-index: 1000;
        }
        #controlsButton:hover {
            background-color: #e94560;
        }
        #controlsPopup {
            display: none;
            position: absolute;
            top: 50px;
            right: 10px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #e94560;
            border-radius: 10px;
            padding: 15px;
            color: white;
            font-size: 14px;
            z-index: 1000;
            width: 200px;
        }
        #controlsPopup.show {
            display: block;
            animation: fadeIn 0.3s ease-in;
        }
        .key {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 8px;
            border-radius: 4px;
            margin: 2px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        .mode-selector {
            margin: 20px auto;
            display: flex;
            justify-content: center;
            gap: 10px;
        }
        .mode-btn {
            padding: 10px 20px;
            font-size: 16px;
            border: 2px solid #e94560;
            background-color: transparent;
            color: #fff;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .mode-btn:hover {
            background-color: rgba(233, 69, 96, 0.2);
        }
        .mode-btn.selected {
            background-color: #e94560;
            color: white;
        }
        /* Add styles for device buttons */
        .device-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            background-color: #2d3436;
        }
        .device-btn:hover {
            background-color: #636e72;
        }
        .device-icon {
            font-size: 24px;
        }
        .device-text {
            font-weight: bold;
        }
        .device-desc {
            font-size: 14px;
            opacity: 0.8;
        }
        .back-btn {
            background-color: #636e72;
        }
        .back-btn:hover {
            background-color: #7f8c8d;
        }
        .menu-btn {
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        /* Android controls */
        .android-controls {
            position: fixed;
            bottom: 20px;
            left: 0;
            right: 0;
            padding: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 800px;
            margin: 0 auto;
            z-index: 9999;
        }
        .control-btn {
            width: 80px;
            height: 80px;
            background-color: rgba(233, 69, 96, 0.9);
            border: 4px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            color: white;
            font-size: 36px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            cursor: pointer;
            position: relative;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        .control-btn:active,
        .control-btn.pressed {
            transform: scale(0.9);
            background-color: rgba(233, 69, 96, 1);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        .direction-btns {
            display: flex;
            gap: 30px;
            margin-left: 30px;
        }
        .jump-control {
            margin-right: 30px;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="score">Score: 0</div>
        <div id="highScore">High Score: 0</div>
        <canvas id="gameCanvas" width="800" height="400"></canvas>
        <button id="controlsButton">Controls</button>
        <div id="controlsPopup">
            <strong>Game Controls:</strong><br><br>
            <div><span class="key">‚Üê</span> <span class="key">‚Üí</span> Move left/right</div>
            <div><span class="key">‚Üë</span> Jump</div>
            <div><span class="key">ESC</span> Pause game</div>
            <div><span class="key">S</span> Save game (when paused)</div>
            <div><span class="key">M</span> Return to menu (when paused)</div>
        </div>
        
        <div id="mainMenu" class="menu">
            <h1>Treasure Hunter</h1>
            <button class="menu-btn" id="playBtn">Play Game</button>
            <button class="menu-btn device-btn" id="desktopBtn" style="display: none;">
                <span class="device-icon">üíª</span>
                <span class="device-text">Desktop</span>
                <span class="device-desc">Play with keyboard controls</span>
            </button>
            <button class="menu-btn device-btn" id="androidBtn" style="display: none;">
                <span class="device-icon">üì±</span>
                <span class="device-text">Mobile</span>
                <span class="device-desc">Play with touch controls</span>
            </button>
            <button class="menu-btn back-btn" id="backBtn" style="display: none;">‚Ü© Back to Menu</button>
            <button class="menu-btn" id="loadBtn">Load Game</button>
            <button class="menu-btn" id="quitBtn">Quit Game</button>
            <div class="mode-selector">
                <button class="mode-btn selected" id="dayModeBtn">Day Mode</button>
                <button class="mode-btn" id="nightModeBtn">Night Mode</button>
            </div>
        </div>

        <div class="game-over-overlay" id="gameOverOverlay">
            <h1>Game Over!</h1>
            <p>Final Score:</p>
            <div class="final-score" id="finalScore">0</div>
            <p id="highScoreMessage"></p>
            <button class="menu-btn" id="restartBtn">Restart Game</button>
            <button class="menu-btn" id="returnToMenuBtn">Return to Menu</button>
        </div>
    </div>

    <!-- Android game controls -->
    <div class="android-controls">
        <div class="direction-btns">
            <button class="control-btn" id="leftBtn" ontouchstart="return false;">‚Üê</button>
            <button class="control-btn" id="rightBtn" ontouchstart="return false;">‚Üí</button>
        </div>
        <div class="jump-control">
            <button class="control-btn" id="jumpBtn" ontouchstart="return false;">‚Üë</button>
        </div>
    </div>

    <script>
        // Wait for DOM to be fully loaded before initializing
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const scoreElement = document.getElementById('score');
            const highScoreElement = document.getElementById('highScore');
            const gameOverOverlay = document.getElementById('gameOverOverlay');
            const finalScoreElement = document.getElementById('finalScore');
            const highScoreMessage = document.getElementById('highScoreMessage');
            const mainMenu = document.getElementById('mainMenu');
            const playBtn = document.getElementById('playBtn');
            const loadBtn = document.getElementById('loadBtn');
            const quitBtn = document.getElementById('quitBtn');
            const returnToMenuBtn = document.getElementById('returnToMenuBtn');
            const controlsButton = document.getElementById('controlsButton');
            const controlsPopup = document.getElementById('controlsPopup');
            const restartBtn = document.getElementById('restartBtn');

            // Android controls
            const leftBtn = document.getElementById('leftBtn');
            const rightBtn = document.getElementById('rightBtn');
            const jumpBtn = document.getElementById('jumpBtn');

            // Touch control event listeners with improved handling
            function setupButton(btn, keyName) {
                let isPressed = false;
                
                function pressButton(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    if (!isPressed) {
                        isPressed = true;
                        btn.classList.add('pressed');
                        keys[keyName] = true;
                        
                        if (keyName === 'ArrowUp' && gameStarted && !player.jumping) {
                            player.jumping = true;
                            player.velocityY = player.jumpPower;
                        }
                    }
                }
                
                function releaseButton(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    isPressed = false;
                    btn.classList.remove('pressed');
                    keys[keyName] = false;
                }

                // Add all event listeners with proper options
                const eventOptions = { passive: false };
                
                // Touch events
                btn.addEventListener('touchstart', pressButton, eventOptions);
                btn.addEventListener('touchmove', pressButton, eventOptions);
                btn.addEventListener('touchend', releaseButton, eventOptions);
                btn.addEventListener('touchcancel', releaseButton, eventOptions);
                
                // Mouse events for testing on desktop
                btn.addEventListener('mousedown', pressButton, eventOptions);
                btn.addEventListener('mouseup', releaseButton, eventOptions);
                btn.addEventListener('mouseleave', releaseButton, eventOptions);
                
                // Prevent context menu
                btn.addEventListener('contextmenu', (e) => e.preventDefault());
            }

            // Setup all buttons
            setupButton(leftBtn, 'ArrowLeft');
            setupButton(rightBtn, 'ArrowRight');
            setupButton(jumpBtn, 'ArrowUp');

            // Make sure controls don't get stuck when game loses focus
            window.addEventListener('blur', () => {
                keys.ArrowLeft = false;
                keys.ArrowRight = false;
                keys.ArrowUp = false;
                document.querySelectorAll('.control-btn').forEach(btn => {
                    btn.classList.remove('pressed');
                });
            });

            // Prevent scrolling while touching buttons
            document.addEventListener('touchmove', (e) => {
                if (e.target.closest('.control-btn')) {
                    e.preventDefault();
                }
            }, { passive: false });

            // Reset controls when game ends or pauses
            function resetControls() {
                keys.ArrowLeft = false;
                keys.ArrowRight = false;
                keys.ArrowUp = false;
                document.querySelectorAll('.control-btn').forEach(btn => {
                    btn.classList.remove('pressed');
                });
            }

            // Add reset controls to relevant game state changes
            function togglePause() {
                if (gameStarted) {
                    gameStarted = false;
                    clearInterval(gameLoop);
                    resetControls();
                    // ... rest of pause code ...
                } else {
                    gameStarted = true;
                    gameLoop = setInterval(update, 1000/60);
                }
            }

            function gameOver() {
                if (gameStarted) {
                    resetControls();
                    handleCollision();
                }
            }

            // Game state
            let score = 0;
            let highScore = 0;
            let gameLoop;
            let gameStarted = false;
            let coinRotation = 0;
            let savedGameState = null;
            let bombFuseAnimation = 0;
            let explosionParticles = [];
            let smokeParticles = [];
            let isNightMode = false;

            // Player setup
            const player = {
                x: 50,
                y: canvas.height - 45,
                width: 30,
                height: 30,
                speed: 3,
                jumping: false,
                velocityY: 0,
                jumpPower: -15,
                gravity: 0.8,
                groundY: canvas.height - 45
            };

            // Controls state
            const keys = {
                ArrowLeft: false,
                ArrowRight: false,
                ArrowUp: false,
                Escape: false
            };

            // Background elements
            const background = {
                sky: {
                    clouds: [],
                    birds: [],
                    birdSpawnTimer: 0,
                    birdSpawnInterval: 2000,
                    lastBirdSpawnTime: 0
                },
                mountains: {
                    offset: 0,
                    points: []
                },
                trees: {
                    baseY: canvas.height - 100,  // Above the road
                    spacing: 70,  // Reduced spacing further for more overlap
                    speed: 2,
                    types: {
                        PINE: 0,
                        ROUND: 1,
                        BUSHY: 2
                    }
                },
                road: {
                    offset: 0,
                    stripeWidth: 50,
                    stripeSpacing: 100
                },
                gameSpeed: 2
            };

            // Collectibles and obstacles
            let collectibles = [];
            let obstacles = [];

            function drawMountains(offset) {
                // Draw mountains that repeat infinitely
                ctx.fillStyle = '#90EE90';  // Light green color

                // Calculate which section of mountains we're seeing based on player position
                const sectionWidth = 1200;  // Width of one complete mountain section
                const currentSection = Math.floor(player.x / sectionWidth);
                
                // Draw mountains for current and next section
                for (let section = currentSection; section <= currentSection + 1; section++) {
                    const sectionOffset = section * sectionWidth;
                    
                    // Mountains in each section
                    [
                        { width: 300, height: 180, xOffset: 0 },
                        { width: 400, height: 150, xOffset: 250 },
                        { width: 350, height: 200, xOffset: 600 },
                        { width: 250, height: 130, xOffset: 900 }
                    ].forEach(mountain => {
                        const mountainX = sectionOffset + mountain.xOffset - player.x;
                        
                        // Only draw if mountain is visible
                        if (mountainX > -mountain.width && mountainX < canvas.width) {
                            // Draw main mountain shape
                            ctx.beginPath();
                            ctx.moveTo(mountainX, canvas.height);
                            ctx.lineTo(mountainX + mountain.width/2, canvas.height - mountain.height);
                            ctx.lineTo(mountainX + mountain.width, canvas.height);
                            ctx.fill();

                            // Add shading
                            ctx.fillStyle = '#7FBF7F';
                            ctx.beginPath();
                            ctx.moveTo(mountainX + mountain.width/2, canvas.height - mountain.height);
                            ctx.lineTo(mountainX + mountain.width * 0.7, canvas.height - mountain.height * 0.7);
                            ctx.lineTo(mountainX + mountain.width * 0.8, canvas.height - mountain.height * 0.5);
                            ctx.lineTo(mountainX + mountain.width/2, canvas.height - mountain.height);
                            ctx.fill();
                            
                            ctx.fillStyle = '#90EE90';
                        }
                    });
                }
            }

            function drawCloud(x, y, width, opacity = 1) {
                ctx.save();
                ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
                ctx.beginPath();
                ctx.arc(x, y, width/2, 0, Math.PI * 2);
                ctx.arc(x + width/3, y - width/6, width/3, 0, Math.PI * 2);
                ctx.arc(x + width/2, y + width/6, width/3, 0, Math.PI * 2);
                ctx.arc(x - width/3, y, width/3, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            function initBackground() {
                // Generate initial birds
                background.sky.birds = [];
                background.sky.birdSpawnInterval = 2000;
                background.sky.lastBirdSpawnTime = 0;
                
                // Create initial set of birds/fireflies at different positions
                const initialCount = isNightMode ? 3 : 4;
                for (let i = 0; i < initialCount; i++) {
                    const spreadWidth = isNightMode ? canvas.width * 2 : canvas.width * 3;
                    background.sky.birds.push({
                        ...createNewBird(),
                        x: Math.random() * spreadWidth - spreadWidth / 2
                    });
                }

                // Generate clouds with varied sizes and very slow speeds
                background.sky.clouds = [];
                for (let i = 0; i < 4; i++) {
                    background.sky.clouds.push({
                        x: Math.random() * canvas.width * 2,
                        y: Math.random() * (canvas.height / 3),
                        width: 80 + Math.random() * 40,
                        speed: 0.05 + Math.random() * 0.03, // Very slow speed
                        opacity: 0.6 + Math.random() * 0.2
                    });
                }
            }

            function drawBackground() {
                // Calculate world offset for parallax effects
                const playerScreenX = canvas.width / 3;
                const worldOffset = player.x - playerScreenX;

                // Draw sky gradient based on mode
                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                if (isNightMode) {
                    // Night sky gradient with more depth
                    gradient.addColorStop(0, '#0a1f44');  // Dark blue at top
                    gradient.addColorStop(0.5, '#1a365d'); // Mid blue
                    gradient.addColorStop(1, '#2a4073');   // Slightly lighter at horizon
                    
                    // Draw stars with parallax effect
                    for (let i = 0; i < 100; i++) {
                        const parallaxFactor = 0.1;
                        const x = (((worldOffset * parallaxFactor) + i * 37) % canvas.width);
                        const y = (i * 23) % (canvas.height * 0.7);
                        const size = Math.random() * 2;
                        const opacity = 0.5 + Math.sin(Date.now() / 1000 + i) * 0.3;
                        
                        ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
                        ctx.beginPath();
                        ctx.arc(x, y, size, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // Draw moon
                    drawMoon(worldOffset);
                } else {
                    gradient.addColorStop(0, '#87CEEB');
                    gradient.addColorStop(1, '#4A90E2');
                }
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Draw birds
                background.sky.birds.forEach(bird => {
                    drawBird(bird);
                });

                // Update and draw clouds - Always draw clouds regardless of mode
                const parallaxFactor = 0.3;
                background.sky.clouds.forEach(cloud => {
                    // Move cloud very slowly
                    cloud.x -= cloud.speed;
                    
                    // Calculate cloud's screen position
                    const screenX = cloud.x - (worldOffset * parallaxFactor);
                    
                    // If cloud moves off screen to the left, reset it to the right
                    if (screenX + cloud.width < -100) {
                        cloud.x = canvas.width + worldOffset * parallaxFactor + Math.random() * 200;
                        cloud.y = Math.random() * (canvas.height / 3);
                        cloud.width = 80 + Math.random() * 40;
                        cloud.speed = 0.05 + Math.random() * 0.03;
                        cloud.opacity = 0.6 + Math.random() * 0.2;
                    }
                    
                    // Draw cloud with adjusted opacity for night/day mode
                    const baseOpacity = isNightMode ? 0.3 : 0.8; // Less visible at night but still present
                    drawCloud(screenX, cloud.y, cloud.width, baseOpacity * cloud.opacity);
                });

                // Draw mountains with adjusted colors for night mode
                ctx.fillStyle = isNightMode ? '#1a4731' : '#90EE90';
                drawMountains(background.mountains.offset);

                // Draw road with adjusted colors for night mode
                drawRoad();
            }

            function update() {
                if (!gameStarted) return;

                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Draw background
                drawBackground();

                // Keep player centered at 1/3 of screen width
                const playerScreenX = canvas.width / 3;

                // Calculate world offset based on player's absolute position
                const worldOffset = player.x - playerScreenX;

                // Update player position in world coordinates
                if (gameStarted) {
                    if (keys.ArrowLeft) {
                        // Prevent moving left beyond the starting point
                        const newX = player.x - player.speed;
                        if (newX >= 50) { // 50 is the initial starting position
                            player.x = newX;
                        }
                    }
                    if (keys.ArrowRight) {
                        // Allow infinite movement to the right
                        player.x += player.speed;
                    }

                    // Handle jumping physics
                    if (player.jumping) {
                        player.velocityY += player.gravity;
                        player.y += player.velocityY;

                        // Ground collision
                        if (player.y >= player.groundY) {
                            player.y = player.groundY;
                            player.jumping = false;
                            player.velocityY = 0;
                        }
                    }
                }

                // Update and draw birds
                background.sky.birds = background.sky.birds.filter(bird => {
                    // Convert bird's world position to screen position
                    const birdScreenX = bird.x - worldOffset;
                    
                    // Update position based on mode
                    if (isNightMode) {
                        // Firefly movement: gentle floating with vertical drift
                        bird.x += bird.speed * 0.5;
                        bird.verticalOffset += bird.verticalSpeed;
                        bird.y += Math.sin(bird.verticalOffset) * 0.8;
                    } else {
                        // Bird movement with gentler wave motion
                        bird.x += bird.speed;
                        bird.y += Math.sin(bird.x / bird.waveFrequency) * bird.waveAmplitude;
                    }
                    
                    // If bird moves off screen, reset it to start
                    if (birdScreenX > canvas.width + bird.size * 2) {
                        bird.x = player.x - canvas.width;  // Reset to left of player's view
                        bird.y = Math.random() * (canvas.height / 3) + 30;
                        return true;
                    }
                    
                    // Draw bird at screen position
                    if (birdScreenX > -bird.size * 2 && birdScreenX < canvas.width + bird.size * 2) {
                        drawBird({
                            ...bird,
                            x: birdScreenX
                        });
                    }
                    return true;
                });

                // Spawn new birds if needed
                const currentTime = Date.now();
                if (currentTime - background.sky.lastBirdSpawnTime > background.sky.birdSpawnInterval) {
                    background.sky.birds.push({
                        ...createNewBird(),
                        x: player.x - canvas.width  // Start from left of player's view
                    });
                    background.sky.lastBirdSpawnTime = currentTime;
                }

                // Tree configuration
                const treeSizes = {
                    SMALL: 40,
                    MEDIUM: 55,
                    LARGE: 70
                };

                // Calculate ground level for trees
                const roadHeight = 30;
                const groundLevel = canvas.height - roadHeight;

                // Tree group configuration
                const treeSpacing = 50;  // Space between trees in a group
                const groupGap = 300;     // Space between groups
                const groupPattern = [3, 6, 5, 4];  // Pattern of trees in each group
                
                // Calculate total length of one complete pattern
                const patternLength = groupPattern.reduce((sum, groupSize) => {
                    return sum + (groupSize * treeSpacing) + groupGap;
                }, 0);

                // Draw trees relative to world offset
                for (let patternRepeat = -2; patternRepeat <= 2; patternRepeat++) {
                    let currentX = -worldOffset + (patternRepeat * patternLength);
                    
                    // Draw each group in the pattern
                    for (let groupIndex = 0; groupIndex < groupPattern.length; groupIndex++) {
                        const groupSize = groupPattern[groupIndex];
                        
                        // Draw trees in current group
                        for (let treeIndex = 0; treeIndex < groupSize; treeIndex++) {
                            const x = currentX + (treeIndex * treeSpacing);
                            
                            // Only draw if tree would be visible (with buffer)
                            if (x > -200 && x < canvas.width + 200) {
                                // Back row (small trees)
                                drawTree(x, 
                                    groundLevel - treeSizes.SMALL + 5, 
                                    treeSizes.SMALL, 
                                    treeIndex % 3);
                                
                                // Middle row (medium trees)
                                drawTree(x + 15, 
                                    groundLevel - treeSizes.MEDIUM + 5, 
                                    treeSizes.MEDIUM, 
                                    (treeIndex + 1) % 3);
                                
                                // Front row (large trees)
                                drawTree(x + 30, 
                                    groundLevel - treeSizes.LARGE + 5, 
                                    treeSizes.LARGE, 
                                    (treeIndex + 2) % 3);
                            }
                        }
                        
                        // Move to next group position
                        currentX += (groupSize * treeSpacing) + groupGap;
                    }
                }

                // Draw road
                drawRoad();

                // Draw player at screen position (not world position)
                if (gameStarted) {
                    ctx.fillStyle = '#e94560';
                    ctx.fillRect(playerScreenX, player.y, player.width, player.height);
                }

                // Update and draw collectibles with world offset
                for (let i = collectibles.length - 1; i >= 0; i--) {
                    const coin = collectibles[i];
                    
                    // Move coin to the left as the world scrolls (same as bombs)
                    coin.x -= background.gameSpeed;
                    
                    // Calculate coin's screen position
                    const coinScreenX = coin.x - worldOffset;
                    
                    // Draw coin at screen position
                    drawCoin(coinScreenX, coin.y, coin.width, coin.height);

                    // Collision with player
                    if (
                        playerScreenX < coinScreenX + coin.width &&
                        playerScreenX + player.width > coinScreenX &&
                        player.y < coin.y + coin.height &&
                        player.y + player.height > coin.y
                    ) {
                        // Collect coin
                        collectibles.splice(i, 1);
                        score += 1;
                        scoreElement.textContent = `Score: ${score}`;
                    } else if (coinScreenX + coin.width < -50) {
                        // Remove coins that have gone off screen
                        collectibles.splice(i, 1);
                    }
                }

                // Draw and update obstacles (bombs)
                for (let i = obstacles.length - 1; i >= 0; i--) {
                    const bomb = obstacles[i];
                    // Move bomb to the left as the world scrolls
                    bomb.x -= background.gameSpeed;
                    
                    // Draw bomb at its position relative to the world offset
                    drawBomb(bomb.x - worldOffset, bomb.y, bomb.width, bomb.height);

                    // Collision with player
                    if (
                        playerScreenX < bomb.x - worldOffset + bomb.width &&
                        playerScreenX + player.width > bomb.x - worldOffset &&
                        player.y < bomb.y + bomb.height &&
                        player.y + player.height > bomb.y
                    ) {
                        // Hit bomb: game over
                        handleCollision(bomb);
                        return;
                    } else if (bomb.x - worldOffset + bomb.width < -50) {
                        // Remove bombs that have gone off screen
                        obstacles.splice(i, 1);
                    }
                }
            }

            function drawInfiniteTrees() {
                // Tree configuration
                const treeConfig = {
                    small: { minSize: 35, maxSize: 45 },
                    medium: { minSize: 50, maxSize: 60 },
                    large: { minSize: 65, maxSize: 75 }
                };

                // Define rows of trees with different depths
                const rows = [
                    { y: canvas.height - 100, parallaxSpeed: 1, sizeMult: 1 },      // Front row
                    { y: canvas.height - 110, parallaxSpeed: 0.8, sizeMult: 0.9 },  // Middle row
                    { y: canvas.height - 120, parallaxSpeed: 0.6, sizeMult: 0.8 }   // Back row
                ];

                // Calculate visible range based on player position
                const treeSpacing = 100;  // Space between trees
                const visibleRange = {
                    start: Math.floor((background.trees.offset * -1) / treeSpacing) - 2,
                    end: Math.floor((background.trees.offset * -1 + canvas.width) / treeSpacing) + 2
                };

                // Draw trees for each row
                rows.forEach(row => {
                    for (let i = visibleRange.start; i <= visibleRange.end; i++) {
                        // Use consistent random size and type based on position
                        const hash = Math.abs(i * 10000 + row.y);
                        const sizeType = hash % 3;  // 0: small, 1: medium, 2: large
                        const treeType = Math.floor(hash / 3) % 3;  // 0: pine, 1: round, 2: bushy

                        // Calculate tree size
                        let baseSize;
                        switch(sizeType) {
                            case 0:
                                baseSize = treeConfig.small.minSize + 
                                    (hash % (treeConfig.small.maxSize - treeConfig.small.minSize));
                                break;
                            case 1:
                                baseSize = treeConfig.medium.minSize + 
                                    (hash % (treeConfig.medium.maxSize - treeConfig.medium.minSize));
                                break;
                            case 2:
                                baseSize = treeConfig.large.minSize + 
                                    (hash % (treeConfig.large.maxSize - treeConfig.large.minSize));
                                break;
                        }

                        // Calculate x position with parallax effect
                        const x = i * treeSpacing + background.trees.offset * row.parallaxSpeed;
                        
                        // Only draw if tree would be visible
                        if (x > -100 && x < canvas.width + 100) {
                            // Add slight random offset to x position based on hash
                            const xOffset = (hash % 20) - 10;
                            drawTree(
                                x + xOffset, 
                                row.y, 
                                baseSize * row.sizeMult,
                                treeType
                            );
                        }
                    }
                });
            }

            function createSmoke(x, y) {
                // Create smoke particles
                for (let i = 0; i < 20; i++) {
                    smokeParticles.push({
                        x: x,
                        y: y,
                        angle: (Math.PI * 2 * i) / 20 + Math.random() * 0.5,
                        speed: 2 + Math.random() * 2,
                        size: 15 + Math.random() * 10,
                        life: 1,
                        color: `rgba(50, 50, 50, 0.8)`
                    });
                }
            }

            function drawSmoke() {
                ctx.save();
                
                // Add subtle screen shake
                if (smokeParticles.length > 0) {
                    const shake = (Math.random() - 0.5) * 3;
                    ctx.translate(shake, shake);
                }

                for (let i = smokeParticles.length - 1; i >= 0; i--) {
                    const particle = smokeParticles[i];
                    
                    // Update particle position
                    particle.x += Math.cos(particle.angle) * particle.speed;
                    particle.y += Math.sin(particle.angle) * particle.speed - 0.5;
                    particle.life -= 0.02;
                    particle.size += 0.5;
                    
                    // Draw smoke particle
                    const gradient = ctx.createRadialGradient(
                        particle.x, particle.y, 0,
                        particle.x, particle.y, particle.size
                    );
                    
                    gradient.addColorStop(0, particle.color);
                    gradient.addColorStop(1, `rgba(50, 50, 50, 0)`);
                    
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    
                    // Remove dead particles
                    if (particle.life <= 0) {
                        smokeParticles.splice(i, 1);
                    }
                }

                ctx.restore();
            }

            function handleCollision(obstacle) {
                // Stop the game immediately
                gameStarted = false;
                
                // Clear any existing game loops
                if (gameLoop) {
                    clearInterval(gameLoop);
                    gameLoop = null;
                }

                // Clear spawn intervals
                if (window.collectibleInterval) clearInterval(window.collectibleInterval);
                if (window.obstacleInterval) clearInterval(window.obstacleInterval);

                // Create smoke at collision point
                createSmoke(obstacle.x + obstacle.width/2, obstacle.y + obstacle.height/2);

                // Start smoke animation
                let smokeTimer = 0;
                const smokeAnimation = setInterval(() => {
                    // Clear and redraw background
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    drawBackground();
                    
                    // Draw remaining collectibles
                    collectibles.forEach(coin => drawCoin(coin.x, coin.y, coin.width, coin.height));
                    
                    // Draw smoke
                    drawSmoke();
                    
                    smokeTimer += 16;
                    
                    // Show game over screen after smoke dissipates
                    if (smokeTimer >= 1000 && smokeParticles.length === 0) {
                        clearInterval(smokeAnimation);
                        
                        // Update high score
                        if (score > highScore) {
                            highScore = score;
                            highScoreElement.textContent = `High Score: ${highScore}`;
                            highScoreMessage.textContent = 'üéâ New High Score! üéâ';
                        } else {
                            highScoreMessage.textContent = `High Score: ${highScore}`;
                        }
                        
                        // Show game over screen
                        gameOverOverlay.style.display = 'block';
                        finalScoreElement.textContent = score;
                    }
                }, 1000/60);
            }

            function checkCollision(rect1, rect2) {
                return rect1.x < rect2.x + rect2.width &&
                       rect1.x + rect1.width > rect2.x &&
                       rect1.y < rect2.y + rect2.height &&
                       rect1.y + rect1.height > rect2.y;
            }

            function spawnCollectibles() {
                // Clear any existing interval
                if (window.collectibleInterval) {
                    clearInterval(window.collectibleInterval);
                }

                // Spawn collectibles on screen
                window.collectibleInterval = setInterval(() => {
                    if (!gameStarted) return;

                    // Calculate spawn position relative to player's view
                    const worldOffset = player.x - canvas.width / 3;
                    const spawnX = worldOffset + canvas.width + 50; // Spawn just off the right edge of screen
                    
                    // Determine number of coins based on random interval (2-6 seconds)
                    const currentTime = Date.now();
                    const lastSpawnTime = window.lastCoinSpawnTime || 0;
                    const timeDiff = currentTime - lastSpawnTime;
                    
                    // Calculate coins based on spawn time (2-6 seconds)
                    const spawnTimeRatio = Math.min(Math.max(timeDiff / 1000 - 2, 0) / 4, 1); // 0 to 1 ratio
                    const coinCount = Math.floor(8 + (spawnTimeRatio * 4)); // 8 to 12 coins
                    
                    // Create scattered coin pattern
                    for (let i = 0; i < coinCount; i++) {
                        // Create random positions within a reasonable area
                        const randomX = spawnX + (Math.random() * 200 - 100); // Spread over 200px width
                        const baseY = player.groundY - 50; // Base height above ground
                        const randomY = baseY + (Math.random() * 100 - 50); // Spread over 100px height
                        
                        collectibles.push({
                            x: randomX,
                            y: randomY,
                            width: 25,  // Reduced from 30
                            height: 25, // Reduced from 30
                            value: 1
                        });
                    }
                    
                    window.lastCoinSpawnTime = currentTime;
                }, 2000); // Check every 2 seconds
            }

            function spawnObstacles() {
                // Clear any existing interval
                if (window.obstacleInterval) {
                    clearInterval(window.obstacleInterval);
                }

                // Spawn obstacles on screen
                window.obstacleInterval = setInterval(() => {
                    if (!gameStarted) return;

                    // Calculate spawn position relative to player's view
                    const worldOffset = player.x - canvas.width / 3;
                    const spawnX = worldOffset + canvas.width + 50; // Spawn just off the right edge of screen
                    
                    // Only spawn if there are less than 5 bombs on screen
                    if (obstacles.length < 5) {
                        // Create a group of bombs with specific patterns
                        const bombGroup = [];
                        
                        // Add two ground-level bombs with spacing
                        const groundY = player.groundY - 20; // Just above ground level
                        bombGroup.push({
                            x: spawnX,
                            y: groundY,
                            width: 40,
                            height: 40
                        });
                        
                        bombGroup.push({
                            x: spawnX + 150, // 150px gap between ground bombs
                            y: groundY,
                            width: 40,
                            height: 40
                        });
                        
                        // Add 3 floating bombs with larger gaps
                        const floatingHeights = [
                            player.groundY - 100, // High
                            player.groundY - 60,  // Medium
                            player.groundY - 80   // Medium-high
                        ];
                        
                        // Add floating bombs with large gaps
                        floatingHeights.forEach((height, index) => {
                            bombGroup.push({
                                x: spawnX + 300 + (index * 200), // 200px gaps between floating bombs
                                y: height,
                                width: 40,
                                height: 40
                            });
                        });
                        
                        // Add all bombs to obstacles array
                        obstacles.push(...bombGroup);
                    }
                }, 10000 + Math.random() * 10000); // Random interval between 10-20 seconds
            }

            function drawCoin(x, y, width, height) {
                ctx.save();
                ctx.translate(x + width/2, y + height/2);
                
                // Slower rotation speed (reduced from 0.02 to 0.01)
                const rotationSpeed = 0.01;
                coinRotation += rotationSpeed;
                
                // Create 3D effect with rotation
                const perspective = Math.cos(coinRotation) * 0.5;
                ctx.scale(Math.abs(perspective) + 0.5, 1);
                
                // Reduce size by about 20%
                const scaleFactor = 0.8;
                ctx.scale(scaleFactor, scaleFactor);
                
                // Determine if showing heads or tails based on rotation
                const showingHeads = perspective > 0;
                
                // Main coin body
                ctx.beginPath();
                ctx.arc(0, 0, width/2, 0, Math.PI * 2);
                ctx.fillStyle = showingHeads ? '#FFD700' : '#DAA520';
                ctx.fill();
                
                // Only draw details if the coin isn't in mid-flip
                if (Math.abs(perspective) > 0.3) {
                    // Outer ring
                    ctx.beginPath();
                    ctx.arc(0, 0, width/2, 0, Math.PI * 2);
                    ctx.strokeStyle = '#B8860B';
                    ctx.lineWidth = 1.5; // Slightly thinner line
                    ctx.stroke();
                    
                    if (showingHeads) {
                        // Heads side design
                        // Inner circle
                        ctx.beginPath();
                        ctx.arc(0, 0, width/3, 0, Math.PI * 2);
                        ctx.strokeStyle = '#B8860B';
                        ctx.lineWidth = 1; // Thinner inner circle
                        ctx.stroke();
                        
                        // Center star
                        const starPoints = 5;
                        const outerRadius = width/4;
                        const innerRadius = width/8;
                        
                        ctx.beginPath();
                        for(let i = 0; i < starPoints * 2; i++) {
                            const radius = i % 2 === 0 ? outerRadius : innerRadius;
                            const angle = (i * Math.PI) / starPoints - Math.PI/2;
                            const x = Math.cos(angle) * radius;
                            const y = Math.sin(angle) * radius;
                            if(i === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                        ctx.closePath();
                        ctx.fillStyle = '#B8860B';
                        ctx.fill();
                    } else {
                        // Tails side design
                        // Decorative circles
                        for (let i = 0; i < 6; i++) {
                            const angle = (i * Math.PI * 2) / 6;
                            const circleX = Math.cos(angle) * width/4;
                            const circleY = Math.sin(angle) * width/4;
                            ctx.beginPath();
                            ctx.arc(circleX, circleY, width/12, 0, Math.PI * 2);
                            ctx.fillStyle = '#B8860B';
                            ctx.fill();
                        }
                        
                        // Center circle
                        ctx.beginPath();
                        ctx.arc(0, 0, width/10, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                // Add shine effect
                const gradient = ctx.createLinearGradient(-width/2, -height/2, width/4, height/4);
                gradient.addColorStop(0, `rgba(255, 255, 255, ${Math.abs(perspective) * 0.5})`);
                gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0)');
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
                ctx.beginPath();
                ctx.arc(0, 0, width/2 - 1, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();
                
                ctx.restore();
            }

            function drawBomb(x, y, width, height) {
                ctx.save();
                ctx.translate(x + width/2, y + height/2);
                
                // Update fuse animation
                bombFuseAnimation += 0.1;

                // Draw smoke
                const smokeY = -height/2 - height/2;
                const smokeX = width/2;
                
                // Draw 3 smoke puffs with different opacities and sizes
                for(let i = 0; i < 3; i++) {
                    const time = Date.now() / 1000 + i * 0.3; // Offset each puff
                    const offsetX = Math.sin(time * 2) * 5;
                    const offsetY = -i * 10 - Math.cos(time * 2) * 3;
                    const opacity = 0.7 - i * 0.2;
                    const size = (3 - i) * 4;
                    
                    ctx.beginPath();
                    ctx.arc(smokeX + offsetX, smokeY + offsetY, size, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(120, 120, 120, ${opacity})`;
                    ctx.fill();
                }

                // Main bomb body gradient
                const bombGradient = ctx.createRadialGradient(
                    -width/6, -height/6,  // Inner circle position (highlight)
                    0,                    // Inner radius
                    0, 0,                 // Outer circle position (center of bomb)
                    width/1.5             // Outer radius
                );
                bombGradient.addColorStop(0, '#454545');    // Highlight
                bombGradient.addColorStop(0.5, '#252525');  // Mid tone
                bombGradient.addColorStop(1, '#151515');    // Shadow

                // Draw main bomb body
                ctx.beginPath();
                ctx.arc(0, 0, width/2 - 2, 0, Math.PI * 2);
                ctx.fillStyle = bombGradient;
                ctx.fill();

                // Add metallic rim at top
                const rimGradient = ctx.createLinearGradient(-width/4, -height/2, width/4, -height/2 + 6);
                rimGradient.addColorStop(0, '#555');
                rimGradient.addColorStop(0.5, '#999');
                rimGradient.addColorStop(1, '#555');

                ctx.beginPath();
                ctx.moveTo(-width/4, -height/2 + 3);
                ctx.quadraticCurveTo(0, -height/2, width/4, -height/2 + 3);
                ctx.quadraticCurveTo(0, -height/2 + 6, -width/4, -height/2 + 3);
                ctx.fillStyle = rimGradient;
                ctx.fill();

                // Draw fuse
                const fuseStart = {x: 0, y: -height/2 + 3};
                const controlPoint = {
                    x: width/3 + Math.sin(bombFuseAnimation) * 2,
                    y: -height/2 - height/3
                };
                const fuseEnd = {
                    x: width/2 + Math.sin(bombFuseAnimation + 1) * 3,
                    y: -height/2 - height/2
                };

                // Main fuse
                ctx.beginPath();
                ctx.moveTo(fuseStart.x, fuseStart.y);
                ctx.quadraticCurveTo(
                    controlPoint.x,
                    controlPoint.y,
                    fuseEnd.x,
                    fuseEnd.y
                );
                const fuseGradient = ctx.createLinearGradient(
                    fuseStart.x, fuseStart.y,
                    fuseEnd.x, fuseEnd.y
                );
                fuseGradient.addColorStop(0, '#8B4513');
                fuseGradient.addColorStop(0.5, '#A0522D');
                fuseGradient.addColorStop(1, '#8B4513');
                ctx.strokeStyle = fuseGradient;
                ctx.lineWidth = 3;
                ctx.stroke();

                // Draw smoke puffs
                const numPuffs = 3;
                for (let i = 0; i < numPuffs; i++) {
                    const puffOffset = i * 8;
                    const smokeX = fuseEnd.x + 5 + Math.sin(bombFuseAnimation * 2 + i) * 3;
                    const smokeY = fuseEnd.y - puffOffset - Math.cos(bombFuseAnimation + i) * 2;
                    const smokeSize = (numPuffs - i) * 3;
                    
                    // Create smoke gradient
                    const smokeGradient = ctx.createRadialGradient(
                        smokeX, smokeY, 0,
                        smokeX, smokeY, smokeSize
                    );
                    smokeGradient.addColorStop(0, 'rgba(100, 100, 100, 0.8)');
                    smokeGradient.addColorStop(1, 'rgba(100, 100, 100, 0)');
                    
                    ctx.beginPath();
                    ctx.arc(smokeX, smokeY, smokeSize, 0, Math.PI * 2);
                    ctx.fillStyle = smokeGradient;
                    ctx.fill();
                }

                // Fuse sparkle animation
                const sparkleX = fuseEnd.x;
                const sparkleY = fuseEnd.y;
                const sparkleSize = 4 + Math.sin(bombFuseAnimation * 2) * 2;

                // Outer glow
                const glowSize = sparkleSize * 2;
                const glow = ctx.createRadialGradient(
                    sparkleX, sparkleY, 0,
                    sparkleX, sparkleY, glowSize
                );
                glow.addColorStop(0, 'rgba(255, 200, 0, 0.4)');
                glow.addColorStop(1, 'rgba(255, 100, 0, 0)');
                ctx.beginPath();
                ctx.arc(sparkleX, sparkleY, glowSize, 0, Math.PI * 2);
                ctx.fillStyle = glow;
                ctx.fill();

                // Sparkle
                ctx.beginPath();
                for(let i = 0; i < 8; i++) {
                    const angle = (i * Math.PI * 2 / 8) + bombFuseAnimation;
                    const innerRadius = sparkleSize * 0.5;
                    const outerRadius = sparkleSize;
                    const x1 = sparkleX + Math.cos(angle) * innerRadius;
                    const y1 = sparkleY + Math.sin(angle) * innerRadius;
                    const x2 = sparkleX + Math.cos(angle) * outerRadius;
                    const y2 = sparkleY + Math.sin(angle) * outerRadius;
                    
                    if(i === 0) {
                        ctx.moveTo(x2, y2);
                    } else {
                        ctx.lineTo(x2, y2);
                    }
                    ctx.lineTo(x1, y1);
                }
                ctx.closePath();
                const sparkleGradient = ctx.createRadialGradient(
                    sparkleX, sparkleY, sparkleSize * 0.3,
                    sparkleX, sparkleY, sparkleSize
                );
                sparkleGradient.addColorStop(0, '#FFF');
                sparkleGradient.addColorStop(0.5, '#FFD700');
                sparkleGradient.addColorStop(1, '#FF4500');
                ctx.fillStyle = sparkleGradient;
                ctx.fill();

                // Highlight on bomb
                const highlight = ctx.createRadialGradient(
                    -width/6, -height/6, 0,
                    -width/6, -height/6, width/3
                );
                highlight.addColorStop(0, 'rgba(255, 255, 255, 0.2)');
                highlight.addColorStop(0.5, 'rgba(255, 255, 255, 0.1)');
                highlight.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
                ctx.beginPath();
                ctx.arc(-width/6, -height/6, width/3, 0, Math.PI * 2);
                ctx.fillStyle = highlight;
                ctx.fill();

                ctx.restore();
            }

            function drawTree(x, y, size, type) {
                ctx.save();
                ctx.translate(x, y);

                // Draw trunk with slight variation in color
                const trunkColor = `rgb(${139 + Math.random() * 20}, ${69 + Math.random() * 10}, ${19 + Math.random() * 10})`;
                ctx.fillStyle = trunkColor;
                ctx.fillRect(-size/8, 0, size/4, size);

                // Draw tree top based on type with color variations
                switch(type) {
                    case background.trees.types.PINE:
                        // Pine tree (triangular) with multiple layers
                        const pineColors = ['#2D5A27', '#355E3B', '#2D4A1E'];
                        for (let i = 0; i < 3; i++) {
                            ctx.fillStyle = pineColors[i];
                            const layerSize = size * (1 - i * 0.2);
                            const layerOffset = size * i * 0.25;
                            
                            ctx.beginPath();
                            ctx.moveTo(-layerSize/1.5, size/2 - layerOffset);
                            ctx.lineTo(0, -size/1.2 + layerOffset);
                            ctx.lineTo(layerSize/1.5, size/2 - layerOffset);
                            ctx.closePath();
                            ctx.fill();
                        }
                        break;

                    case background.trees.types.ROUND:
                        // Round tree with multiple layers of foliage
                        const roundColors = ['#355E3B', '#2D5A27', '#1B4D2E'];
                        ctx.fillStyle = roundColors[0];
                        ctx.beginPath();
                        ctx.arc(0, -size/3, size/1.5, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = roundColors[1];
                        ctx.beginPath();
                        ctx.arc(-size/3, -size/2, size/2, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = roundColors[2];
                        ctx.beginPath();
                        ctx.arc(size/3, -size/2, size/2, 0, Math.PI * 2);
                        ctx.fill();
                        break;

                    case background.trees.types.BUSHY:
                        // Bushy tree with multiple detailed clusters
                        const bushyColors = ['#355E3B', '#2D5A27', '#1B4D2E'];
                        const clusters = [
                            {x: 0, y: -size/1.2, r: size/2},
                            {x: -size/2, y: -size/2, r: size/2.5},
                            {x: size/2, y: -size/2, r: size/2.5},
                            {x: -size/3, y: -size/3, r: size/2.5},
                            {x: size/3, y: -size/3, r: size/2.5},
                            {x: 0, y: -size/2, r: size/2}
                        ];
                        
                        clusters.forEach((cluster, i) => {
                            ctx.fillStyle = bushyColors[i % 3];
                            ctx.beginPath();
                            ctx.arc(cluster.x, cluster.y, cluster.r, 0, Math.PI * 2);
                            ctx.fill();
                        });
                        break;
                }

                ctx.restore();
            }

            function createNewBird() {
                const size = isNightMode ? (4 + Math.random() * 2) : (12 + Math.random() * 3); // Smaller for fireflies
                
                // Bird color palette
                const birdColors = [
                    '#485460', // Dark gray
                    '#1e272e', // Charcoal
                    '#786fa6', // Dusty purple
                    '#596275', // Steel gray
                    '#574b90', // Deep purple
                    '#303952', // Navy blue
                    '#6D214F', // Dark burgundy
                    '#2C3A47'  // Slate gray
                ];
                
                return {
                    x: -size * 2, // Start from left side
                    y: Math.random() * (canvas.height / 2) + 30, // Higher range for fireflies
                    size: size,
                    wingPosition: Math.random() * Math.PI * 2,
                    wingSpeed: isNightMode ? 0.1 + Math.random() * 0.05 : 0.15 + Math.random() * 0.05, // Much slower wing movement
                    speed: isNightMode ? 1 + Math.random() : 1.2 + Math.random() * 0.8, // Much slower movement
                    color: birdColors[Math.floor(Math.random() * birdColors.length)], // Random color from palette
                    headTilt: Math.sin(Date.now() / 1000) * 0.1,
                    type: Math.floor(Math.random() * 3),
                    // Firefly specific properties
                    verticalOffset: Math.random() * Math.PI * 2,
                    verticalSpeed: 0.02 + Math.random() * 0.01,
                    // Additional movement properties
                    waveAmplitude: 0.2 + Math.random() * 0.3, // Gentler wave motion
                    waveFrequency: 150 + Math.random() * 50 // Slower wave frequency
                };
            }

            function drawBird(bird) {
                if (isNightMode) {
                    // Draw firefly in night mode
                    ctx.save();
                    ctx.translate(bird.x, bird.y);

                    // Create pulsing glow effect
                    const glowIntensity = 0.5 + Math.sin(bird.wingPosition) * 0.3;
                    
                    // Outer glow
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, bird.size * 2);
                    gradient.addColorStop(0, `rgba(255, 255, 150, ${glowIntensity})`);
                    gradient.addColorStop(0.5, `rgba(255, 255, 100, ${glowIntensity * 0.3})`);
                    gradient.addColorStop(1, 'rgba(255, 255, 0, 0)');
                    
                    ctx.beginPath();
                    ctx.fillStyle = gradient;
                    ctx.arc(0, 0, bird.size * 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Inner bright core
                    ctx.beginPath();
                    ctx.fillStyle = `rgba(255, 255, 200, ${glowIntensity + 0.2})`;
                    ctx.arc(0, 0, bird.size * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                } else {
                    // Draw bird in day mode
                    ctx.save();
                    ctx.translate(bird.x, bird.y);
                    
                    // Add slight forward tilt
                    const flyingTilt = -0.1; // Subtle forward tilt
                    ctx.rotate(flyingTilt + bird.headTilt);

                    // Draw based on bird type
                    switch(bird.type) {
                        case 0: // Small bird (sparrow-like)
                            drawSmallBird(bird);
                            break;
                        case 1: // Medium bird (swallow-like)
                            drawMediumBird(bird);
                            break;
                        case 2: // Large bird (hawk-like)
                            drawLargeBird(bird);
                            break;
                    }
                    
                    ctx.restore();
                }
                bird.wingPosition += isNightMode ? 0.03 : bird.wingSpeed; // Slower pulsing for fireflies
            }

            function drawSmallBird(bird) {
                const wingY = Math.sin(bird.wingPosition) * 4;
                
                // Body
                ctx.fillStyle = bird.color;
                ctx.beginPath();
                ctx.ellipse(0, 0, bird.size * 0.7, bird.size * 0.4, 0, 0, Math.PI * 2);
                ctx.fill();

                // Wings
                drawDetailedWing(bird, -bird.size * 0.3, -bird.size * 0.1, wingY, 0.7, true);
                drawDetailedWing(bird, bird.size * 0.3, -bird.size * 0.1, wingY, 0.7, false);

                // Tail
                drawDetailedTail(bird, -bird.size * 0.6, 0, 0.5);

                // Head
                ctx.beginPath();
                ctx.arc(bird.size * 0.5, -bird.size * 0.15, bird.size * 0.25, 0, Math.PI * 2);
                ctx.fill();

                // Eye
                drawDetailedEye(bird, bird.size * 0.6, -bird.size * 0.2, 0.12);

                // Beak
                drawDetailedBeak(bird, bird.size * 0.7, -bird.size * 0.15, 0.25);
            }

            function drawMediumBird(bird) {
                const wingY = Math.sin(bird.wingPosition) * 5;
                
                // Body
                ctx.fillStyle = bird.color;
                ctx.beginPath();
                ctx.ellipse(0, 0, bird.size * 0.8, bird.size * 0.45, 0, 0, Math.PI * 2);
                ctx.fill();

                // Wings
                drawDetailedWing(bird, -bird.size * 0.4, -bird.size * 0.15, wingY, 0.8, true);
                drawDetailedWing(bird, bird.size * 0.4, -bird.size * 0.15, wingY, 0.8, false);

                // Forked Tail
                drawForkedTail(bird, -bird.size * 0.7, 0, 0.6);

                // Head
                ctx.beginPath();
                ctx.arc(bird.size * 0.6, -bird.size * 0.2, bird.size * 0.3, 0, Math.PI * 2);
                ctx.fill();

                // Eye
                drawDetailedEye(bird, bird.size * 0.7, -bird.size * 0.25, 0.15);

                // Beak
                drawDetailedBeak(bird, bird.size * 0.85, -bird.size * 0.2, 0.3);
            }

            function drawLargeBird(bird) {
                const wingY = Math.sin(bird.wingPosition) * 6;
                
                // Body
                ctx.fillStyle = bird.color;
                ctx.beginPath();
                ctx.ellipse(0, 0, bird.size * 0.9, bird.size * 0.5, 0, 0, Math.PI * 2);
                ctx.fill();

                // Wings
                drawDetailedWing(bird, -bird.size * 0.5, -bird.size * 0.2, wingY, 0.9, true);
                drawDetailedWing(bird, bird.size * 0.5, -bird.size * 0.2, wingY, 0.9, false);

                // Tail
                drawDetailedTail(bird, -bird.size * 0.8, 0, 0.7);

                // Head
                ctx.beginPath();
                ctx.arc(bird.size * 0.7, -bird.size * 0.25, bird.size * 0.35, 0, Math.PI * 2);
                ctx.fill();

                // Eye
                drawDetailedEye(bird, bird.size * 0.8, -bird.size * 0.3, 0.18);

                // Hooked Beak
                drawHookedBeak(bird, bird.size * 0.9, -bird.size * 0.25, 0.35);
            }

            function drawDetailedWing(bird, x, y, wingY, scale, isLeft) {
                ctx.fillStyle = bird.color;
                ctx.beginPath();
                ctx.moveTo(x, y);
                
                // Primary feathers
                const featherSpread = isLeft ? -1 : 1;
                ctx.quadraticCurveTo(
                    x + (bird.size * scale * featherSpread), 
                    y + wingY, 
                    x + (bird.size * 0.2 * featherSpread), 
                    y + wingY + bird.size * 0.3
                );
                
                // Secondary feathers
                ctx.quadraticCurveTo(
                    x + (bird.size * 0.1 * featherSpread), 
                    y + wingY * 0.5, 
                    x, 
                    y
                );
                ctx.fill();
            }

            function drawDetailedTail(bird, x, y, scale) {
                ctx.fillStyle = bird.color;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x - bird.size * 0.4, y + bird.size * 0.15);
                ctx.lineTo(x - bird.size * 0.3, y - bird.size * 0.15);
                ctx.closePath();
                ctx.fill();
            }

            function drawForkedTail(bird, x, y, scale) {
                ctx.fillStyle = bird.color;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x - bird.size * 0.5, y + bird.size * 0.2);
                ctx.lineTo(x - bird.size * 0.3, y);
                ctx.lineTo(x - bird.size * 0.5, y - bird.size * 0.2);
                ctx.closePath();
                ctx.fill();
            }

            function drawDetailedEye(bird, x, y, scale) {
                // White of eye
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(x, y, bird.size * scale, 0, Math.PI * 2);
                ctx.fill();
                
                // Pupil
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(x + bird.size * scale * 0.2, y, bird.size * scale * 0.5, 0, Math.PI * 2);
                ctx.fill();
            }

            function drawDetailedBeak(bird, x, y, scale) {
                ctx.fillStyle = '#666'; // Darker beak color
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + bird.size * scale, y + bird.size * 0.05);
                ctx.lineTo(x, y + bird.size * 0.1);
                ctx.closePath();
                ctx.fill();
            }

            function drawHookedBeak(bird, x, y, scale) {
                ctx.fillStyle = '#666';
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.quadraticCurveTo(
                    x + bird.size * scale,
                    y,
                    x + bird.size * scale,
                    y + bird.size * 0.15
                );
                ctx.lineTo(x, y + bird.size * 0.1);
                ctx.closePath();
                ctx.fill();
            }

            function drawRoad() {
                const roadHeight = 30;
                const stripeWidth = 50;
                const stripeGap = 50;
                const totalStripeWidth = stripeWidth + stripeGap;

                // Draw main road with adjusted color for night
                ctx.fillStyle = isNightMode ? '#333' : '#444';
                ctx.fillRect(0, canvas.height - roadHeight, canvas.width, roadHeight);

                // Draw stripes with adjusted opacity for night
                ctx.fillStyle = isNightMode ? 'rgba(255, 255, 255, 0.5)' : '#FFF';
                for(let x = 0; x < canvas.width + totalStripeWidth; x += totalStripeWidth) {
                    ctx.fillRect(
                        x,
                        canvas.height - roadHeight/2 - 2,
                        stripeWidth,
                        4
                    );
                }

                // Calculate world offset based on player's position
                const playerScreenX = canvas.width / 3;
                const worldOffset = player.x - playerScreenX;

                // Draw infinite scrolling street lights
                const lampSpacing = 300; // Space between each lamp
                const firstVisibleLamp = Math.floor(worldOffset / lampSpacing) * lampSpacing;
                const lastVisibleLamp = firstVisibleLamp + canvas.width + lampSpacing;

                // Draw all visible lamps
                for (let x = firstVisibleLamp; x <= lastVisibleLamp; x += lampSpacing) {
                    const screenX = x - worldOffset;
                    drawStreetLightPole(screenX, canvas.height - roadHeight);
                }
            }

            function drawStreetLightPole(x, baseY) {
                const poleHeight = 140;
                const lampSize = 15;
                
                // Only draw light effects during night mode
                if (isNightMode) {
                    // Draw light effect
                    const gradient = ctx.createRadialGradient(
                        x, baseY - poleHeight + lampSize,
                        0,
                        x, baseY - poleHeight + lampSize,
                        100
                    );
                    gradient.addColorStop(0, 'rgba(255, 244, 179, 0.6)');
                    gradient.addColorStop(0.5, 'rgba(255, 244, 179, 0.2)');
                    gradient.addColorStop(1, 'rgba(255, 244, 179, 0)');
                    
                    ctx.beginPath();
                    ctx.fillStyle = gradient;
                    ctx.arc(x, baseY - poleHeight + lampSize, 100, 0, Math.PI * 2);
                    ctx.fill();

                    // Draw light cone
                    ctx.beginPath();
                    ctx.fillStyle = 'rgba(255, 244, 179, 0.2)';
                    ctx.moveTo(x - 2, baseY - poleHeight + lampSize);
                    ctx.lineTo(x - 60, baseY);
                    ctx.lineTo(x + 60, baseY);
                    ctx.lineTo(x + 2, baseY - poleHeight + lampSize);
                    ctx.fill();
                }

                // Draw pole
                ctx.beginPath();
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 4;
                ctx.moveTo(x, baseY);
                ctx.lineTo(x, baseY - poleHeight);
                ctx.stroke();

                // Draw lamp housing
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.moveTo(x - 15, baseY - poleHeight + 5);
                ctx.lineTo(x + 15, baseY - poleHeight + 5);
                ctx.lineTo(x + 10, baseY - poleHeight + 20);
                ctx.lineTo(x - 10, baseY - poleHeight + 20);
                ctx.closePath();
                ctx.fill();

                // Draw lamp (glowing only at night)
                ctx.beginPath();
                ctx.fillStyle = isNightMode ? 'rgba(255, 244, 179, 1)' : '#666';
                ctx.arc(x, baseY - poleHeight + lampSize, lampSize/2, 0, Math.PI * 2);
                ctx.fill();

                // Add bright center to lamp only at night
                if (isNightMode) {
                    ctx.beginPath();
                    ctx.fillStyle = '#FFF';
                    ctx.arc(x, baseY - poleHeight + lampSize, lampSize/4, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            function togglePause() {
                if (gameStarted) {
                    gameStarted = false;
                    clearInterval(gameLoop);
                    resetControls();
                    
                    // Draw pause menu
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = 'white';
                    ctx.font = '36px Arial';
                    ctx.fillText('PAUSED', canvas.width/2 - 70, canvas.height/2 - 50);
                    ctx.font = '24px Arial';
                    ctx.fillText('Press ESC to resume', canvas.width/2 - 100, canvas.height/2);
                    ctx.fillText('Press S to save game', canvas.width/2 - 100, canvas.height/2 + 40);
                    ctx.fillText('Press M to return to menu', canvas.width/2 - 120, canvas.height/2 + 80);
                } else {
                    gameStarted = true;
                    gameLoop = setInterval(update, 1000/60);
                }
            }

            function saveGame() {
                if (!gameStarted) {
                    const gameState = {
                        score: score,
                        highScore: highScore,
                        player: { ...player },
                        collectibles: [...collectibles],
                        obstacles: [...obstacles],
                        background: { ...background }
                    };
                    localStorage.setItem('treasureHunterSave', JSON.stringify(gameState));
                    
                    // Show save confirmation
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
                    ctx.fillRect(canvas.width/2 - 100, canvas.height/2 + 120, 200, 40);
                    ctx.fillStyle = 'white';
                    ctx.font = '20px Arial';
                    ctx.fillText('Game Saved!', canvas.width/2 - 50, canvas.height/2 + 145);
                }
            }

            function loadGame() {
                const savedState = localStorage.getItem('treasureHunterSave');
                if (savedState) {
                    const gameState = JSON.parse(savedState);
                    score = gameState.score;
                    highScore = gameState.highScore;
                    player = { ...gameState.player };
                    collectibles = [...gameState.collectibles];
                    obstacles = [...gameState.obstacles];
                    background = { ...gameState.background };
                    
                    // Start game with loaded state
                    startNewGame();
                } else {
                    // Show no save data message
                    alert('No saved game found!');
                }
            }

            function quitGame() {
                if (confirm('Are you sure you want to quit the game?')) {
                    try {
                        window.close();
                    } catch (e) {
                        // If window.close() fails, return to menu and show message
                        returnToMenu();
                        alert('Cannot close the window. You can safely close the tab manually.');
                    }
                }
            }

            function returnToMenu() {
                // Clear any running game loops
                clearInterval(gameLoop);
                gameStarted = false;
                
                // Hide game elements
                canvas.style.display = 'none';
                scoreElement.style.display = 'none';
                highScoreElement.style.display = 'none';
                controlsButton.style.display = 'none';
                gameOverOverlay.style.display = 'none';
                
                // Show main menu
                mainMenu.style.display = 'block';
                
                // Reset game state
                score = 0;
                collectibles = [];
                obstacles = [];
                player.x = 50;
                player.y = canvas.height - 50;
                player.jumping = false;
                player.velocityY = 0;
            }

            // Event listeners
            document.addEventListener('keydown', (e) => {
                if (keys.hasOwnProperty(e.key)) {
                    e.preventDefault();
                    keys[e.key] = true;
                    
                    // Only allow jumping if game has started and player is on ground
                    if (e.key === 'ArrowUp' && gameStarted && !player.jumping) {
                        player.jumping = true;
                        player.velocityY = player.jumpPower;
                    }
                }
                if (e.key === 'Escape' && gameStarted) {
                    togglePause();
                }
                if (!gameStarted && e.key === 's') {
                    saveGame();
                } else if (!gameStarted && e.key === 'm') {
                    returnToMenu();
                }
            });

            document.addEventListener('keyup', (e) => {
                if (keys.hasOwnProperty(e.key)) {
                    e.preventDefault();
                    keys[e.key] = false;
                }
            });

            function startNewGame() {
                // Hide menu, show game
                mainMenu.style.display = 'none';
                canvas.style.display = 'block';
                scoreElement.style.display = 'block';
                highScoreElement.style.display = 'block';
                controlsButton.style.display = 'block';
                gameOverOverlay.style.display = 'none';
                
                // Initialize background
                initBackground();
                
                // Reset game state
                score = 0;
                scoreElement.textContent = `Score: ${score}`;
                highScoreElement.textContent = `High Score: ${highScore}`;
                
                // Reset player position
                player.x = 50;
                player.y = player.groundY;
                player.jumping = false;
                player.velocityY = 0;
                
                // Clear arrays
                collectibles = [];
                obstacles = [];
                smokeParticles = [];
                
                // Reset background offsets
                background.mountains.offset = 0;
                background.road.offset = 0;

                // Start game immediately
                gameStarted = true;
                gameLoop = setInterval(update, 1000/60);
                spawnCollectibles();
                spawnObstacles();
            }

            // Initialize button listeners
            playBtn.addEventListener('click', startNewGame);
            playBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                startNewGame();
            });

            loadBtn.addEventListener('click', loadGame);
            loadBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                loadGame();
            });

            quitBtn.addEventListener('click', quitGame);
            quitBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                quitGame();
            });

            returnToMenuBtn.addEventListener('click', returnToMenu);
            returnToMenuBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                returnToMenu();
            });

            restartBtn.addEventListener('click', () => {
                gameOverOverlay.style.display = 'none';
                startNewGame();
            });
            restartBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                gameOverOverlay.style.display = 'none';
                startNewGame();
            });

            // Add touch events for mode buttons
            dayModeBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                dayModeBtn.classList.add('selected');
                nightModeBtn.classList.remove('selected');
                isNightMode = false;
            });

            nightModeBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                nightModeBtn.classList.add('selected');
                dayModeBtn.classList.remove('selected');
                isNightMode = true;
            });

            // Add controls button functionality
            controlsButton.addEventListener('click', (e) => {
                e.stopPropagation();
                controlsPopup.classList.toggle('show');
            });

            // Close popup when clicking outside
            document.addEventListener('click', (e) => {
                if (!controlsPopup.contains(e.target) && e.target !== controlsButton) {
                    controlsPopup.classList.remove('show');
                }
            });

            // Add the mode selection buttons
            const dayModeBtn = document.getElementById('dayModeBtn');
            const nightModeBtn = document.getElementById('nightModeBtn');

            dayModeBtn.addEventListener('click', () => {
                dayModeBtn.classList.add('selected');
                nightModeBtn.classList.remove('selected');
                isNightMode = false;
            });

            nightModeBtn.addEventListener('click', () => {
                nightModeBtn.classList.add('selected');
                dayModeBtn.classList.remove('selected');
                isNightMode = true;
            });

            function drawMoon(worldOffset) {
                // Calculate moon position with parallax (moves slower than the world)
                const parallaxFactor = 0.02; // Very slow parallax for distant moon effect
                const baseX = canvas.width - 100; // Base position on right side
                const moonX = baseX - (worldOffset * parallaxFactor);
                const moonY = 80; // Position moon higher in the sky
                const moonRadius = 40;
                
                // Create outer glow effect
                const moonGlow = ctx.createRadialGradient(
                    moonX, moonY, moonRadius * 0.8,
                    moonX, moonY, moonRadius * 2.5
                );
                moonGlow.addColorStop(0, 'rgba(255, 255, 200, 0.3)');
                moonGlow.addColorStop(0.5, 'rgba(255, 255, 200, 0.1)');
                moonGlow.addColorStop(1, 'rgba(255, 255, 200, 0)');
                
                // Draw the glow
                ctx.beginPath();
                ctx.fillStyle = moonGlow;
                ctx.arc(moonX, moonY, moonRadius * 2.5, 0, Math.PI * 2);
                ctx.fill();

                // Draw the main moon
                const moonGradient = ctx.createRadialGradient(
                    moonX - moonRadius * 0.2, moonY - moonRadius * 0.2, 0,
                    moonX, moonY, moonRadius
                );
                moonGradient.addColorStop(0, '#FFFDE7');  // Warm center
                moonGradient.addColorStop(0.2, '#FFF8E1'); // Slightly cooler
                moonGradient.addColorStop(1, '#FFE082');   // Slight yellow tint at edge

                ctx.beginPath();
                ctx.fillStyle = moonGradient;
                ctx.arc(moonX, moonY, moonRadius, 0, Math.PI * 2);
                ctx.fill();

                // Add subtle crater details
                const craters = [
                    { x: -0.2, y: 0.1, size: 0.15 },
                    { x: 0.3, y: -0.2, size: 0.1 },
                    { x: 0.1, y: 0.3, size: 0.12 }
                ];

                craters.forEach(crater => {
                    const craterX = moonX + crater.x * moonRadius;
                    const craterY = moonY + crater.y * moonRadius;
                    const craterSize = crater.size * moonRadius;

                    // Draw slightly darker crater
                    const craterGradient = ctx.createRadialGradient(
                        craterX, craterY, 0,
                        craterX, craterY, craterSize
                    );
                    craterGradient.addColorStop(0, 'rgba(189, 189, 189, 0.2)');
                    craterGradient.addColorStop(1, 'rgba(189, 189, 189, 0)');

                    ctx.beginPath();
                    ctx.fillStyle = craterGradient;
                    ctx.arc(craterX, craterY, craterSize, 0, Math.PI * 2);
                    ctx.fill();
                });

                // Add stars around the moon for extra effect
                const starCount = 15;
                for (let i = 0; i < starCount; i++) {
                    const angle = (i / starCount) * Math.PI * 2;
                    const distance = moonRadius * (2 + Math.random());
                    const starX = moonX + Math.cos(angle) * distance;
                    const starY = moonY + Math.sin(angle) * distance;
                    const starSize = 1 + Math.random();
                    
                    // Create twinkling effect
                    const starOpacity = 0.5 + Math.sin(Date.now() / 1000 + i) * 0.3;
                    
                    ctx.beginPath();
                    ctx.fillStyle = `rgba(255, 255, 255, ${starOpacity})`;
                    ctx.arc(starX, starY, starSize, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        });
    </script>
</body>
</html>
